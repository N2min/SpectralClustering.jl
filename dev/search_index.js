var documenterSearchIndex = {"docs":
[{"location":"man/incremental/#Incremental-Spectral-Clustering-1","page":"Incremental","title":"Incremental Spectral Clustering","text":"","category":"section"},{"location":"man/embedding/#Eigenvector-Embedding-1","page":"Embedding","title":"Eigenvector Embedding","text":"","category":"section"},{"location":"man/embedding/#","page":"Embedding","title":"Embedding","text":"Spectral clustering techniques require the computation of the extreme eigenvectors of matrices derived from patterns similarity . The Laplacian matrix obtained from the data is generally used as the starting point for decomposition into autovectors. Given the symmetric matrix $ W (i, j) = w_{ij}, W \\in R^{n \\times n} $ that contains information about  similarity between the patterns, if $ D = W \\mathbf {1} $, the unnormalized Laplacian matrix is defined as $ L = D-W $.","category":"page"},{"location":"man/embedding/#","page":"Embedding","title":"Embedding","text":"The matrix $ W $ can be seen as the incidence matrix of a weighted graph. The Simmilarity graph creation utilities implement functions that allow the construction of simmilarty graphs.","category":"page"},{"location":"man/embedding/#","page":"Embedding","title":"Embedding","text":"The Embedding utilities contain the functions for performing the embedding of the patterns in the space spanned by the $ k $ eigenvectors of a matrix derived from W.","category":"page"},{"location":"man/embedding/#","page":"Embedding","title":"Embedding","text":"Currently the module implements the techniques described in:","category":"page"},{"location":"man/embedding/#","page":"Embedding","title":"Embedding","text":"On spectral clustering: Analysis and an algorithm.\nNormalized cuts and image segmentation.\nUnderstanding Popout through Repulsion.\nSegmentation Given Partial Grouping Constraints","category":"page"},{"location":"man/embedding/#Examples-1","page":"Embedding","title":"Examples","text":"","category":"section"},{"location":"man/embedding/#","page":"Embedding","title":"Embedding","text":"Embedding examples","category":"page"},{"location":"man/embedding/#Bibliography-1","page":"Embedding","title":"Bibliography","text":"","category":"section"},{"location":"man/embedding/#","page":"Embedding","title":"Embedding","text":"import Documenter.Documents.RawHTML\nBase.include(@__MODULE__, \"DocUtils.jl\")\nRawHTML(bibliography([\"ng2002spectral\",\"shi2000normalized\",\"yu2001understanding\", \"yu2004segmentation\",\"lee2007trajectory\"]))","category":"page"},{"location":"man/embedding/#Index-1","page":"Embedding","title":"Index","text":"","category":"section"},{"location":"man/embedding/#","page":"Embedding","title":"Embedding","text":"Modules=[SpectralClustering]\nPages=[\"man/embedding.md\"]","category":"page"},{"location":"man/embedding/#Content-1","page":"Embedding","title":"Content","text":"","category":"section"},{"location":"man/embedding/#","page":"Embedding","title":"Embedding","text":"Modules=[SpectralClustering]\nPages=[\"src/Embedding.jl\"]","category":"page"},{"location":"man/embedding/#SpectralClustering.NgLaplacian","page":"Embedding","title":"SpectralClustering.NgLaplacian","text":"type NgLaplacian <: AbstractEmbedding\n\nMembers\n\nnev::Integer. The number of eigenvectors to obtain\nnormalize::Bool. Wether normalize the obtained eigenvectors\n\nGiven a affinity matrix W in mathbbR^n times n.  Ng et al defines the laplacian as L =  D^-frac12 W D^-frac12 where D is a diagonal matrix whose (i,i)-element is the sum of W's i-th row.\n\nThe embedding function solves a relaxed version of the following optimization problem: ``\\begin{array}{crclcl}     \\displaystyle \\max_{ U \\in \\mathbb{R}^{n\\times k} \\hspace{10pt} } & \\mathrm{Tr}(U^T L  U)  &\\\n   \\textrm{s.a.}  {U^T U}  =   I && \\end{array}``\n\nU is a matrix that contains the nev  largest eigevectors of L.\n\nReferences\n\nOn Spectral Clustering: Analysis and an algorithm. Andrew Y. Ng, Michael I. Jordan, Yair Weiss\n\n\n\n\n\n","category":"type"},{"location":"man/embedding/#SpectralClustering.PartialGroupingConstraints","page":"Embedding","title":"SpectralClustering.PartialGroupingConstraints","text":"struct PartialGroupingConstraints <: AbstractEmbedding\n\nMembers\n\nnev::Integer. The number of eigenvector to obtain.\nsmooth::Bool. Whether to user Smooth Constraints\nnormalize::Bool. Whether to normalize the rows of the obtained vectors\n\nSegmentation Given Partial Grouping Constraints Stella X. Yu and Jianbo Shi\n\n\n\n\n\n","category":"type"},{"location":"man/embedding/#SpectralClustering.ShiMalikLaplacian","page":"Embedding","title":"SpectralClustering.ShiMalikLaplacian","text":"The normalized laplacian as defined in  D^-frac12 (D-W) D^-frac12.\n\nReferences:\n\nSpectral Graph Theory. Fan Chung\nNormalized Cuts and Image Segmentation. Jiambo Shi and Jitendra Malik\n\ntype ShiMalikLaplacian <: AbstractEmbedding\n\nMembers\n\nnev::Integer. The number of eigenvector to obtain.\nnormalize::Bool. Wether normalize the obtained eigenvectors\n\n\n\n\n\n","category":"type"},{"location":"man/embedding/#SpectralClustering.embedding-Tuple{NgLaplacian,AbstractArray{T,2} where T}","page":"Embedding","title":"SpectralClustering.embedding","text":"embedding(cfg::NgLaplacian, L::SparseMatrixCSC)\n\nPerforms the eigendecomposition of the laplacian matrix of the weight matrix W defined according to NgLaplacian\n\n\n\n\n\n","category":"method"},{"location":"man/embedding/#SpectralClustering.embedding-Tuple{NgLaplacian,LightGraphs.LinAlg.CombinatorialAdjacency}","page":"Embedding","title":"SpectralClustering.embedding","text":"embedding(cfg::NgLaplacian, W::CombinatorialAdjacency)\n\nPerforms the eigendecomposition of the laplacian matrix of the weight matrix W defined according to NgLaplacian\n\n\n\n\n\n","category":"method"},{"location":"man/embedding/#SpectralClustering.embedding-Tuple{NgLaplacian,LightGraphs.LinAlg.NormalizedAdjacency}","page":"Embedding","title":"SpectralClustering.embedding","text":"embedding(cfg::NgLaplacian, L::NormalizedAdjacency)\n\nPerforms the eigendecomposition of the laplacian matrix of the weight matrix W defined according to NgLaplacian\n\n\n\n\n\n","category":"method"},{"location":"man/embedding/#SpectralClustering.embedding-Tuple{PartialGroupingConstraints,Graph,Array{Array{Integer,1},1}}","page":"Embedding","title":"SpectralClustering.embedding","text":"embedding(cfg::PartialGroupingConstraints, gr::Graph, restrictions::Vector{Vector{Integer}})\n\nArguments\n\ncfg::PartialGroupingConstraints\nL::NormalizedAdjacency\nrestrictions::Vector{Vector{Integer}}\n\n\n\n\n\n","category":"method"},{"location":"man/embedding/#SpectralClustering.embedding-Tuple{PartialGroupingConstraints,LightGraphs.LinAlg.NormalizedAdjacency,Array{Array{Integer,1},1}}","page":"Embedding","title":"SpectralClustering.embedding","text":"function embedding(cfg::PartialGroupingConstraints, L::NormalizedAdjacency, restrictions::Vector{Vector{Integer}})\n\nArguments\n\ncfg::PartialGroupingConstraints\nL::NormalizedAdjacency\nrestrictions::Vector{Vector{Integer}}\n\n\n\n\n\n","category":"method"},{"location":"man/embedding/#SpectralClustering.embedding-Tuple{ShiMalikLaplacian,LightGraphs.LinAlg.CombinatorialAdjacency}","page":"Embedding","title":"SpectralClustering.embedding","text":"embedding(cfg::NgLaplacian, W::CombinatorialAdjacency)\n\nPerforms the eigendecomposition of the laplacian matrix of the weight matrix W defined according to NgLaplacian\n\n\n\n\n\n","category":"method"},{"location":"man/embedding/#SpectralClustering.embedding-Tuple{ShiMalikLaplacian,LightGraphs.LinAlg.NormalizedLaplacian}","page":"Embedding","title":"SpectralClustering.embedding","text":"embedding(cfg::ShiMalikLaplacian, L::NormalizedLaplacian)\n\nParameters\n\ncfg::ShiMalikLaplacian. An instance of a ShiMalikLaplacian  that specify the number of eigenvectors to obtain\ngr::Union{Graph,SparseMatrixCSC}. The Graph(@ref Graph) or the weight matrix of wich is going to be computed the normalized laplacian matrix.\n\nPerforms the eigendecomposition of the normalized laplacian matrix of the laplacian matriz L defined acoording to ShiMalikLaplacian. Returns the cfg.nev eigenvectors associated with the non-zero smallest eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"man/embedding/#SpectralClustering.embedding-Tuple{YuShiPopout,Graph,Graph,Array{Array{Integer,1},1}}","page":"Embedding","title":"SpectralClustering.embedding","text":"function embedding(cfg::YuShiPopout,  grA::Graph, grR::Graph)\n\nReferences\n\nGrouping with Directed Relationships. Stella X. Yu and Jianbo Shi\nUnderstanding Popout through Repulsion. Stella X. Yu and Jianbo Shi\n\n\n\n\n\n","category":"method"},{"location":"man/embedding/#SpectralClustering.embedding-Tuple{YuShiPopout,Graph,Graph}","page":"Embedding","title":"SpectralClustering.embedding","text":"function embedding(cfg::YuShiPopout,  grA::Graph, grR::Graph)\n\nReferences\n\nGrouping with Directed Relationships. Stella X. Yu and Jianbo Shi\nUnderstanding Popout through Repulsion. Stella X. Yu and Jianbo Shi\n\n\n\n\n\n","category":"method"},{"location":"man/embedding/#SpectralClustering.embedding-Union{Tuple{T}, Tuple{T,Graph}} where T<:SpectralClustering.AbstractEmbedding","page":"Embedding","title":"SpectralClustering.embedding","text":"embedding(cfg::T, gr::Graph) where T<:AbstractEmbedding\n\nPerforms the eigendecomposition of the laplacian matrix of the weight matrix W derived from the graph gr defined according to NgLaplacian\n\n\n\n\n\n","category":"method"},{"location":"man/embedding/#SpectralClustering.embedding-Union{Tuple{T}, Tuple{T,VertexNeighborhood,Function,Any}} where T<:SpectralClustering.AbstractEmbedding","page":"Embedding","title":"SpectralClustering.embedding","text":"embedding{T<:AbstractEmbedding}(cfg::T, neighborhood::VertexNeighborhood, oracle::Function, data)\n\n\n\n\n\n","category":"method"},{"location":"man/embedding/#SpectralClustering.PGCMatrix","page":"Embedding","title":"SpectralClustering.PGCMatrix","text":"struct PGCMatrix{T,I,F} <: AbstractMatrix{T}\n\nPartial grouping constraint structure. This sturct is passed to eigs to performe the L*x computation according to (41), (42) and (43) of \"\"Segmentation Given Partial Grouping Constraints\"\"\n\n\n\n\n\n","category":"type"},{"location":"start/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/multiview/#MultiView-Embedding-1","page":"Co-Regularized","title":"MultiView Embedding","text":"","category":"section"},{"location":"man/multiview/#","page":"Co-Regularized","title":"Co-Regularized","text":"When the dataset has more than one representation, each of them is named view. In the context of spectral clustering,  co-regularization techniques attempt to encourage the similarity of the examples in the new representation generated  from the eigenvectors of each view.","category":"page"},{"location":"man/multiview/#Examples-1","page":"Co-Regularized","title":"Examples","text":"","category":"section"},{"location":"man/multiview/#","page":"Co-Regularized","title":"Co-Regularized","text":"MultiView Embedding examples","category":"page"},{"location":"man/multiview/#Reference-Index-1","page":"Co-Regularized","title":"Reference Index","text":"","category":"section"},{"location":"man/multiview/#","page":"Co-Regularized","title":"Co-Regularized","text":"Modules = [SpectralClustering]\nPages=[\"man/data_access.md\"]","category":"page"},{"location":"man/multiview/#Members-Documentation-1","page":"Co-Regularized","title":"Members Documentation","text":"","category":"section"},{"location":"man/multiview/#","page":"Co-Regularized","title":"Co-Regularized","text":"Modules = [SpectralClustering]\nPages=[\"MultiView.jl\"]","category":"page"},{"location":"man/multiview/#SpectralClustering.CoRegularizedMultiView","page":"Co-Regularized","title":"SpectralClustering.CoRegularizedMultiView","text":"Co-regularized Multi-view Spectral Clustering\n\nAbhishek Kumar, Piyush Rai, Hal Daumé\n\n\n\n\n\n","category":"type"},{"location":"man/multiview/#SpectralClustering.View","page":"Co-Regularized","title":"SpectralClustering.View","text":"A view\n\nstruct View\n    embedder::NgLaplacian\n    lambda::Float64\nend\n\nMembers\n\n- embedder::EigenvectorEmbedder\n- lambda::Float64\n\n\n\n\n\n","category":"type"},{"location":"man/multiview/#SpectralClustering.embedding-Tuple{CoRegularizedMultiView,Array{Graph,1}}","page":"Co-Regularized","title":"SpectralClustering.embedding","text":"embedding(cfg::CoRegularizedMultiView, X::Vector)\n\nArguments\n\n- `cfg::CoRegularizedMultiView`\n- `X::Vector{Graph}`\n\nAn example that shows how to use this methods is provied in the Usage section of the manual\n\n\n\n\n\n","category":"method"},{"location":"man/multiview/#SpectralClustering.LargeScaleMultiView","page":"Co-Regularized","title":"SpectralClustering.LargeScaleMultiView","text":"type LargeScaleMultiView\n\nLarge-Scale Multi-View Spectral Clustering via Bipartite Graph. In AAAI (pp. 2750-2756).\n\nLi, Y., Nie, F., Huang, H., & Huang, J. (2015, January).\n\nMatlab implementation\n\nMembers\n\nk::Integer. Number of clusters.\nn_salient_points::Integer. Number of salient points.\nk_nn::Integer. k nearest neighbors.\n'gamma::Float64`.\n\n\n\n\n\n","category":"type"},{"location":"man/approximate/#Approximate-embedding-1","page":"Approximate Embedding","title":"Approximate embedding","text":"","category":"section"},{"location":"man/approximate/#","page":"Approximate Embedding","title":"Approximate Embedding","text":"Given a symmetric affinity matrix $A$, we would like to compute the $k$ smallest eigenvectors of the Laplacian of A. Directly computing such eigenvectors can be very costly even with sophisticated solvers, due to the large size of $A$.","category":"page"},{"location":"man/approximate/#Examples-1","page":"Approximate Embedding","title":"Examples","text":"","category":"section"},{"location":"man/approximate/#","page":"Approximate Embedding","title":"Approximate Embedding","text":"Approximate embedding examples","category":"page"},{"location":"man/approximate/#Bibliography-1","page":"Approximate Embedding","title":"Bibliography","text":"","category":"section"},{"location":"man/approximate/#","page":"Approximate Embedding","title":"Approximate Embedding","text":"import Documenter.Documents.RawHTML\nBase.include(@__MODULE__, \"DocUtils.jl\")\nRawHTML(bibliography([\"pont2017multiscale\"]))","category":"page"},{"location":"man/approximate/#Reference-1","page":"Approximate Embedding","title":"Reference","text":"","category":"section"},{"location":"man/approximate/#Index-1","page":"Approximate Embedding","title":"Index","text":"","category":"section"},{"location":"man/approximate/#","page":"Approximate Embedding","title":"Approximate Embedding","text":"Modules=[SpectralClustering]\nPages=[\"man/approximate.md\"]","category":"page"},{"location":"man/approximate/#Content-1","page":"Approximate Embedding","title":"Content","text":"","category":"section"},{"location":"man/approximate/#","page":"Approximate Embedding","title":"Approximate Embedding","text":"\nPages=[\"ApproximateEmbedding.jl\"]\nModules=[SpectralClustering]","category":"page"},{"location":"man/approximate/#SpectralClustering.DNCuts","page":"Approximate Embedding","title":"SpectralClustering.DNCuts","text":"type DNCuts\n\nMultiscale Combinatorial Grouping for Image Segmentation and Object Proposal Generation\n\nJordi Pont-Tuset, Pablo Arbeláez, Jonathan T. Barron, Member, Ferran Marques, Jitendra Malik\n\n\n\n\n\n","category":"type"},{"location":"man/approximate/#SpectralClustering.LandmarkBasedRepresentation","page":"Approximate Embedding","title":"SpectralClustering.LandmarkBasedRepresentation","text":"Large Scale Spectral Clustering with Landmark-Based Representation Xinl ei Chen Deng Cai\n\nMembers\n\nlandmark_selector::{T <: AbstractLandmarkSelection} Method for extracting landmarks\nnumber_of_landmarks::Integer Number of landmarks to obtain\nn_neighbors::Integer Number of nearest neighbors\nnev::Integer Number of eigenvectors\nw::Function Number of clusters to obtain\nnormalize::Bool\n\n\n\n\n\n","category":"type"},{"location":"man/approximate/#SpectralClustering.NystromMethod","page":"Approximate Embedding","title":"SpectralClustering.NystromMethod","text":"\ntype NystromMethod{T<:AbstractLandmarkSelection}\nlandmarks_selector::T\nnumber_of_landmarks::Integer\nw::Function\nnvec::Integer\nend\n\nThe type NystromMethod proposed in  Spectral Grouping Using the Nystrom Method by Charless Fowlkes, Serge Belongie, Fan Chung, and Jitendra Malik. It has to be defined:\n\nlandmarks_selector::T<:AbstractLandmarkSelection. A mechanism to select the sampled\n\npoints.\n\nnumber_of_landmarks::Integer. The number of points to sample\nw::Function. The weight function for compute the similiarity. The signature of the weight function has to be weight(i, j, e1,e2). Where e1 and e2 ara the data elements i-th and j-th respectivily, obtained via get_element, usually is a vector.\nnvec::Integer. The number of eigenvector to obtain.\nthreaded::Bool. Default: True. Specifies whether the threaded version is used.\n\n\n\n\n\n","category":"type"},{"location":"man/approximate/#SpectralClustering.embedding-Tuple{DNCuts,AbstractArray{T,2} where T}","page":"Approximate Embedding","title":"SpectralClustering.embedding","text":"embedding(d::DNCuts, L)\n\n\n\n\n\n","category":"method"},{"location":"man/approximate/#SpectralClustering.embedding-Tuple{LandmarkBasedRepresentation,Any}","page":"Approximate Embedding","title":"SpectralClustering.embedding","text":"embedding(cfg::LandmarkBasedRepresentation, X)\n\n\n\n\n\n","category":"method"},{"location":"man/approximate/#SpectralClustering.embedding-Tuple{NystromMethod,Any}","page":"Approximate Embedding","title":"SpectralClustering.embedding","text":"embedding(cfg::NystromMethod, X)\n\nThis is an overloaded function\n\n\n\n\n\n","category":"method"},{"location":"man/approximate/#SpectralClustering.embedding-Tuple{NystromMethod,Array{#s21,1} where #s21<:Integer,Any}","page":"Approximate Embedding","title":"SpectralClustering.embedding","text":"embedding(cfg::NystromMethod, landmarks::Vector{Int}, X)\n\nArguments\n\ncfg::[NystromMethod](@ref)\nlandmarks::Vector{Int}\nx::Any\n\nReturn values\n\n(E, L): The approximated eigenvectors, the aprooximated eigenvalues\n\nPerforms the eigenvector embedding according to\n\n\n\n\n\n","category":"method"},{"location":"man/approximate/#SpectralClustering.embedding-Tuple{NystromMethod,Array{T,2} where T,Array{T,2} where T,Array{#s45,1} where #s45<:Integer}","page":"Approximate Embedding","title":"SpectralClustering.embedding","text":"embedding(cfg::NystromMethod, A::Matrix, B::Matrix, landmarks::Vector{Int})\n\nPerforms the eigenvector approximation given the two submatrices A and B.\n\n\n\n\n\n","category":"method"},{"location":"man/approximate/#SpectralClustering.create_A_B-Tuple{NystromMethod,Any}","page":"Approximate Embedding","title":"SpectralClustering.create_A_B","text":"createAB(cfg::NystromMethod, X)\n\nArguments:\n\ncfg::NystromMethod\nX\n\n#Return values\n\nSub-matrix A\nSub-matrix B\nVector{Int}. The sampled points used build the sub-matrices\n\nThis is an overloaded method. Computes the submatrix A and B according to create_A_B(::NystromMethod, ::Vector{Int}, ::Any). Returns the two submatrices and the sampled points used to calcluate it\n\n\n\n\n\n","category":"method"},{"location":"man/approximate/#SpectralClustering.create_A_B-Tuple{NystromMethod,Array{#s16,1} where #s16<:Integer,Any}","page":"Approximate Embedding","title":"SpectralClustering.create_A_B","text":"createAB(cfg::NystromMethod, landmarks::Vector{Int},X)\n\nArguments:\n\ncfg::NystromMethod. The method configuration.\nlandmarks::Vector{T}. A vector of integer that containts the n indexes sampled from the data.\nX is the data that containt $ N $ patterns.\n\nLet $ W \\in \\mathbb{R}^{N \\times N}, W = \\begin{bmatrix} A & B^T \\ B & C \\end{bmatrix}, A \\in \\mathbb{R}^{ n \\times n }, B \\in \\mathbb{R}^{(N-n) \\times n}, C \\in \\mathbb{R}^{(N-n)\\times (N-n)} $ . A represents the subblock of weights among the random samples, B contains the weights from the random samples to the rest of the pixels, and C contains the weights between all of the remaining pixels. The function computes A and B from the data X using the weight function defined in cfg.\n\n\n\n\n\n","category":"method"},{"location":"man/landmark_selection/#Landmark-Selection-1","page":"Landmarks Selection","title":"Landmark Selection","text":"","category":"section"},{"location":"man/landmark_selection/#","page":"Landmarks Selection","title":"Landmarks Selection","text":"In order to avoid the construction of a complete similarity matrix some spectral clustering methods compute the simmilarity function between a subset of patterns. This module provides an interface to sample points from diferentes data structures.","category":"page"},{"location":"man/landmark_selection/#","page":"Landmarks Selection","title":"Landmarks Selection","text":"Methods availaible:","category":"page"},{"location":"man/landmark_selection/#","page":"Landmarks Selection","title":"Landmarks Selection","text":"Random . This selection method samples k random points from a dataset\nEvenlySpaced. This selection method samples spaced evenly acorrding ther index.","category":"page"},{"location":"man/landmark_selection/#Detailed-Description-1","page":"Landmarks Selection","title":"Detailed Description","text":"","category":"section"},{"location":"man/landmark_selection/#Random-Landmark-Selection-1","page":"Landmarks Selection","title":"Random Landmark Selection","text":"","category":"section"},{"location":"man/landmark_selection/#","page":"Landmarks Selection","title":"Landmarks Selection","text":"using SpectralClustering\nnumber_of_points = 20\ndimension = 5\ndata = rand(dimension,number_of_points)\nselector = RandomLandmarkSelection()\nnumber_of_landmarks = 7\nselect_landmarks(selector, number_of_landmarks, data )","category":"page"},{"location":"man/landmark_selection/#Evenly-Spaced-Landmark-Selection-1","page":"Landmarks Selection","title":"Evenly Spaced Landmark Selection","text":"","category":"section"},{"location":"man/landmark_selection/#","page":"Landmarks Selection","title":"Landmarks Selection","text":"using SpectralClustering\nnumber_of_points = 20\ndimension = 5\ndata = rand(dimension,number_of_points)\nselector = EvenlySpacedLandmarkSelection()\nnumber_of_landmarks = 5\nselect_landmarks(selector, number_of_landmarks, data )\n","category":"page"},{"location":"man/landmark_selection/#Index-1","page":"Landmarks Selection","title":"Index","text":"","category":"section"},{"location":"man/landmark_selection/#","page":"Landmarks Selection","title":"Landmarks Selection","text":"Modules=[SpectralClustering]\nPages=[\"man/landmark_selection.md\"]","category":"page"},{"location":"man/landmark_selection/#Content-1","page":"Landmarks Selection","title":"Content","text":"","category":"section"},{"location":"man/landmark_selection/#","page":"Landmarks Selection","title":"Landmarks Selection","text":"Modules=[SpectralClustering]\nPages=[\"src/LandmarkSelection.jl\"]","category":"page"},{"location":"man/landmark_selection/#SpectralClustering.AbstractLandmarkSelection","page":"Landmarks Selection","title":"SpectralClustering.AbstractLandmarkSelection","text":"abstract type AbstractLandmarkSelection end\n\nAbstract type that defines how to sample data points. Types that inherint from AbstractLandmarkSelection has to implements the following interface:\n\nselect_landmarks{L<:AbstractLandmarkSelection}(c::L, X)\n\nThe select_landmarksfunction returns an array with the indices of the sampled points.\n\nArguments\n\nc::T<:AbstractLandmarkSelecion. The landmark selection type.\nd::D<:DataAccessor.  The DataAccessor type.\nX. The data. The data to be sampled.\n\n\n\n\n\n","category":"type"},{"location":"man/landmark_selection/#SpectralClustering.EvenlySpacedLandmarkSelection","page":"Landmarks Selection","title":"SpectralClustering.EvenlySpacedLandmarkSelection","text":"struct EvenlySpacedLandmarkSelection <: AbstractLandmarkSelection\n\nThe EvenlySpacedLandmarkSelection selection method selects  n evenly spaced points  from a dataset.\n\n\n\n\n\n","category":"type"},{"location":"man/landmark_selection/#SpectralClustering.select_landmarks-Tuple{EvenlySpacedLandmarkSelection,Integer,Any}","page":"Landmarks Selection","title":"SpectralClustering.select_landmarks","text":"select_landmarks(c::EvenlySpacedLandmarkSelection,n::Integer, X)\n\n\n\n\n\n","category":"method"},{"location":"man/landmark_selection/#SpectralClustering.select_landmarks-Tuple{RandomLandmarkSelection,Integer,Any}","page":"Landmarks Selection","title":"SpectralClustering.select_landmarks","text":"select_landmarks(c::RandomLandmarkSelection,d::T,n::Integer, X)\n\nThe function returns nrandom points according to RandomLandmarkSelection\n\nArguments\n\nc::RandomLandmarkSelection.\nn::Integer. The number of data points to sample.\nX. The data to be sampled.\n\n\n\n\n\n","category":"method"},{"location":"man/graph/#Graphs-1","page":"Graph","title":"Graphs","text":"","category":"section"},{"location":"man/graph/#Reference-1","page":"Graph","title":"Reference","text":"","category":"section"},{"location":"man/graph/#Index-1","page":"Graph","title":"Index","text":"","category":"section"},{"location":"man/graph/#","page":"Graph","title":"Graph","text":"Pages=[\"man/graph.md\"]\nModules=[SpectralClustering]","category":"page"},{"location":"man/graph/#Content-1","page":"Graph","title":"Content","text":"","category":"section"},{"location":"man/graph/#","page":"Graph","title":"Graph","text":"\nPages=[\"Graph/Graphs.jl\"]\nModules=[SpectralClustering]","category":"page"},{"location":"man/graph/#SpectralClustering.Graph","page":"Graph","title":"SpectralClustering.Graph","text":"Graph(n_vertices::Integer=0; vertex_type::DataType  = Any ,initial_value=nothing, weight_type::DataType = Float64)\n\nConstruct an undirected weighted grpah of n_vertices vertices.\n\n\n\n\n\n","category":"type"},{"location":"man/graph/#SpectralClustering.connect!-Tuple{Graph,Integer,Array{T,1} where T,Array{T,1} where T}","page":"Graph","title":"SpectralClustering.connect!","text":"function connect!(g::Graph, i::Integer, neighbors::Vector, weigths::Vector)\n\n\n\n\n\n","category":"method"},{"location":"man/graph/#SpectralClustering.connect!-Tuple{Graph,Integer,Integer,Number}","page":"Graph","title":"SpectralClustering.connect!","text":"connect!(g::Graph,i::Integer,j::Integer,w::Number)\n\nConnect the vertex i with the vertex j with weight w.\n\n\n\n\n\n","category":"method"},{"location":"man/graph/#SpectralClustering.disconnect-Tuple{Graph,Integer,Integer}","page":"Graph","title":"SpectralClustering.disconnect","text":"disconnect(g::Graph,i::Integer,j::Integer)\n\nRemoves the edge that connects the i-th vertex to the j-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"man/graph/#SpectralClustering.random_graph-Tuple{Integer}","page":"Graph","title":"SpectralClustering.random_graph","text":"function random_graph(iterations::Integer; probs=[0.4,0.4,0.2], weight=()->5, debug=false)\n\nCreate a random graphs. probs is an array of probabilities. The function create a vertex with probability probs[1], connect two vertices with probability probs[2] and delete a vertex with probability probs[2]. The weight of the edges is given by weight\n\n\n\n\n\n","category":"method"},{"location":"man/graph/#SpectralClustering.remove_vertex!-Tuple{Graph,Integer}","page":"Graph","title":"SpectralClustering.remove_vertex!","text":"remove_vertex!(g::Graph,i::Integer)\n\nRemove the i-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"man/graph/#SpectralClustering.target_vertex-Tuple{SpectralClustering.Edge,SpectralClustering.Vertex}","page":"Graph","title":"SpectralClustering.target_vertex","text":"target_vertex(e::Edge,v::Vertex)\n\nGiven an edge e and a vertex v returns the other vertex different from v\n\n\n\n\n\n","category":"method"},{"location":"man/graph/#SpectralClustering.Edge","page":"Graph","title":"SpectralClustering.Edge","text":"type Edge\n\n\n\n\n\n","category":"type"},{"location":"man/graph/#Base.length-Tuple{SpectralClustering.Vertex}","page":"Graph","title":"Base.length","text":"length(v::Vertex)\n\nReturn the number of edges connected to a given vertex.\n\n\n\n\n\n","category":"method"},{"location":"man/graph/#LightGraphs.nv-Tuple{Graph}","page":"Graph","title":"LightGraphs.nv","text":"nv(g::Graph)\n\nReturn the number of vertices of g.\n\n\n\n\n\n","category":"method"},{"location":"man/data_access/#Data-Access-1","page":"Data Access","title":"Data Access","text":"","category":"section"},{"location":"man/data_access/#","page":"Data Access","title":"Data Access","text":"In order to establish how the data is going to be accessed, the module DataAccess provides an unified interface to access to the data for the underlaying algorithms. Every DataAccessor must implement this two methods:","category":"page"},{"location":"man/data_access/#","page":"Data Access","title":"Data Access","text":"get_element(d::T, X, i::Integer). This function must return the i-th pattern of X.\nnumber_of_patterns(d::T,X). This function must return the numer of patterns of X","category":"page"},{"location":"man/data_access/#Reference-Index-1","page":"Data Access","title":"Reference Index","text":"","category":"section"},{"location":"man/data_access/#","page":"Data Access","title":"Data Access","text":"Modules = [SpectralClustering]\nPages=[\"man/data_access.md\"]","category":"page"},{"location":"man/data_access/#Members-Documentation-1","page":"Data Access","title":"Members Documentation","text":"","category":"section"},{"location":"man/data_access/#","page":"Data Access","title":"Data Access","text":"Modules = [SpectralClustering]\nPages=[\"Utils/DataAccess.jl\"]","category":"page"},{"location":"man/data_access/#SpectralClustering.assign!-Union{Tuple{T}, Tuple{C}, Tuple{T,C}} where T<:AbstractArray where C<:ColorTypes.Colorant","page":"Data Access","title":"SpectralClustering.assign!","text":"function assign!(vec::T, val::C) where T<:AbstractArray where C<:Colorant\n\nThis function assigns the components of the color component val to a vector v\n\n\n\n\n\n","category":"method"},{"location":"man/data_access/#SpectralClustering.get_element!-Union{Tuple{D}, Tuple{C}, Tuple{D,Array{C,2},Array{#s19,1} where #s19<:Integer}} where D<:AbstractArray where C<:ColorTypes.Colorant","page":"Data Access","title":"SpectralClustering.get_element!","text":"function get_element!(o::Matrix,  img::Matrix{C}, i::Vector{Integer}) where C<:Colorant\n\n\n\n\n\n\n","category":"method"},{"location":"man/data_access/#SpectralClustering.get_element!-Union{Tuple{T}, Tuple{C}, Tuple{T,Array{C,2},Integer}} where T<:AbstractArray where C<:ColorTypes.Colorant","page":"Data Access","title":"SpectralClustering.get_element!","text":"get_element!{T<:AbstractArray}(vec::T,  img::Matrix{Gray}, i::Integer)\n\nReturn throughvec the intensity image element  [x,y, i], where xy are the spatial position of the pixel and the value i of the pixel (xy).\n\n\n\n\n\n","category":"method"},{"location":"man/data_access/#SpectralClustering.get_element-Union{Tuple{T}, Tuple{Array{T,2},Array{T,1} where T}} where T<:ColorTypes.Colorant","page":"Data Access","title":"SpectralClustering.get_element","text":"function get_element( img::Matrix{RGB}, i::Vector)\n\n\n\n\n\n","category":"method"},{"location":"man/data_access/#SpectralClustering.get_element-Union{Tuple{T}, Tuple{Array{T,3},Array{T,1} where T}} where T<:Number","page":"Data Access","title":"SpectralClustering.get_element","text":"function get_element(data::Array{T, 3}, i::Vector)  where T<:Number\n\n\n\n\n\n","category":"method"},{"location":"man/data_access/#SpectralClustering.number_of_patterns-Union{Tuple{Array{T,2}}, Tuple{T}} where T<:ColorTypes.Colorant","page":"Data Access","title":"SpectralClustering.number_of_patterns","text":"number_of_patterns{T<:Any}(X::Matrix{T,3})\n\nReturn the number of pixels in the image\n\n\n\n\n\n","category":"method"},{"location":"man/data_access/#SpectralClustering.spatial_position-Tuple{Array{T,2} where T,Any}","page":"Data Access","title":"SpectralClustering.spatial_position","text":" spatial_position(X::Matrix, i::Int)\n\nReturns the sub indexes from the linear index i\n\n\n\n\n\n","category":"method"},{"location":"man/clusterize/#Eigenvector-Clustering-1","page":"Eigenvector Clustering","title":"Eigenvector Clustering","text":"","category":"section"},{"location":"man/clusterize/#","page":"Eigenvector Clustering","title":"Eigenvector Clustering","text":"Once the eigenvectors are obtained, we have a continuous solution for a discrete problem. In order to obtain an assigment for every pattern,  it is needed to discretize the eigenvectors. Obtaining this discrete solution from eigenvectors often requires solving another clustering problem, albeit in a lower-dimensional space. That is, eigenvectors are treated as geometrical coordinates of a point set.","category":"page"},{"location":"man/clusterize/#","page":"Eigenvector Clustering","title":"Eigenvector Clustering","text":"This library provides two methods two obtain the discrete solution:","category":"page"},{"location":"man/clusterize/#","page":"Eigenvector Clustering","title":"Eigenvector Clustering","text":"Kmeans by means of Clustering.jl\nThe one proposed in Multiclass spectral clustering","category":"page"},{"location":"man/clusterize/#Examples-1","page":"Eigenvector Clustering","title":"Examples","text":"","category":"section"},{"location":"man/clusterize/#","page":"Eigenvector Clustering","title":"Eigenvector Clustering","text":"Eigenvector clusterization examples","category":"page"},{"location":"man/clusterize/#Reference-Index-1","page":"Eigenvector Clustering","title":"Reference Index","text":"","category":"section"},{"location":"man/clusterize/#","page":"Eigenvector Clustering","title":"Eigenvector Clustering","text":"Modules = [SpectralClustering]\nPages=[\"man/data_access.md\"]","category":"page"},{"location":"man/clusterize/#Members-Documentation-1","page":"Eigenvector Clustering","title":"Members Documentation","text":"","category":"section"},{"location":"man/clusterize/#","page":"Eigenvector Clustering","title":"Eigenvector Clustering","text":"Modules = [SpectralClustering]\nPages=[\"EigenvectorClustering.jl\"]","category":"page"},{"location":"man/clusterize/#SpectralClustering.KMeansClusterizer","page":"Eigenvector Clustering","title":"SpectralClustering.KMeansClusterizer","text":"struct KMeansClusterizer <: EigenvectorClusterizer\n    k::Integer\n    init::Symbol\nend\n\n\n\n\n\n","category":"type"},{"location":"man/clusterize/#SpectralClustering.YuEigenvectorRotation","page":"Eigenvector Clustering","title":"SpectralClustering.YuEigenvectorRotation","text":"Multiclass Spectral Clustering\n\n\n\n\n\n","category":"type"},{"location":"man/clusterize/#SpectralClustering.clusterize-Union{Tuple{T}, Tuple{C}, Tuple{T,C,Any,Vararg{Any,N} where N}} where T<:EigenvectorEmbedder where C<:EigenvectorClusterizer","page":"Eigenvector Clustering","title":"SpectralClustering.clusterize","text":"function clusterize{T<:EigenvectorEmbedder, C<:EigenvectorClusterizer}(cfg::T, clus::C, X)\n\nGiven a set of patterns X generates an eigenvector space according to T<:EigenvectorEmbeddder and then clusterize the eigenvectors using the algorithm defined by C<:EigenvectorClusterize.\n\n\n\n\n\n","category":"method"},{"location":"man/clusterize/#Bibliography-1","page":"Eigenvector Clustering","title":"Bibliography","text":"","category":"section"},{"location":"man/clusterize/#","page":"Eigenvector Clustering","title":"Eigenvector Clustering","text":"import Documenter.Documents.RawHTML\nBase.include(@__MODULE__, \"DocUtils.jl\")\nRawHTML(bibliography([\"stella2003multiclass\"]))","category":"page"},{"location":"man/graphcreation/#Simmilarity-graph-creation-1","page":"Graph Creation","title":"Simmilarity graph creation","text":"","category":"section"},{"location":"man/graphcreation/#","page":"Graph Creation","title":"Graph Creation","text":"A weighted graph is an ordered pair G=(VE) that is composed of a set V of vertices together with a set E of edges (ijw) ij in Vw in R. The number w, the weight, represent the simmilarity between i and j.","category":"page"},{"location":"man/graphcreation/#","page":"Graph Creation","title":"Graph Creation","text":"In order to build a simmilarity graph two elements have to be defined:","category":"page"},{"location":"man/graphcreation/#","page":"Graph Creation","title":"Graph Creation","text":"Which are the neighbors for a given vertex. For this, a concrete type that inherit from NeighborhoodConfig  has to be instantiated. \nThe simmilarity function between patterns.  The function receives the element being evaluated and its neighbors and returns a vector with the simmilarities between them.  The signature of the function has to be the following function weight(i::Integer, j::Vector{Integer}, e1, e2) where i::Int is the index of the pattern being evaluated, j::Vector{Integer}  are the indices of the neighbors of i;  e1 are the i-th pattern and  e2 are the  neighbors patterns.","category":"page"},{"location":"man/graphcreation/#Examples-1","page":"Graph Creation","title":"Examples","text":"","category":"section"},{"location":"man/graphcreation/#","page":"Graph Creation","title":"Graph Creation","text":"Graph creation examples","category":"page"},{"location":"man/graphcreation/#Bibliography-1","page":"Graph Creation","title":"Bibliography","text":"","category":"section"},{"location":"man/graphcreation/#","page":"Graph Creation","title":"Graph Creation","text":"import Documenter.Documents.RawHTML\nBase.include(@__MODULE__, \"DocUtils.jl\")\nRawHTML(bibliography([\"Zelnik-manor04self-tuningspectral\"]))","category":"page"},{"location":"man/graphcreation/#Reference-1","page":"Graph Creation","title":"Reference","text":"","category":"section"},{"location":"man/graphcreation/#Index-1","page":"Graph Creation","title":"Index","text":"","category":"section"},{"location":"man/graphcreation/#","page":"Graph Creation","title":"Graph Creation","text":"Modules=[SpectralClustering]\nPages   = [\"man/graphcreation.md\"]","category":"page"},{"location":"man/graphcreation/#Content-1","page":"Graph Creation","title":"Content","text":"","category":"section"},{"location":"man/graphcreation/#","page":"Graph Creation","title":"Graph Creation","text":"Modules=[SpectralClustering]\nPages=[\"Graph/Creation.jl\"]","category":"page"},{"location":"man/graphcreation/#SpectralClustering.CliqueNeighborhood","page":"Graph Creation","title":"SpectralClustering.CliqueNeighborhood","text":"struct CliqueNeighborhood <: VertexNeighborhood\n\nCliqueNeighborhood specifies that the neighborhood for a given vertex j in a graph of n vertices are the remaining n-1 vertices.\n\n\n\n\n\n","category":"type"},{"location":"man/graphcreation/#SpectralClustering.KNNNeighborhood","page":"Graph Creation","title":"SpectralClustering.KNNNeighborhood","text":"struct KNNNeighborhood <: VertexNeighborhood\n    k::Integer\n    tree::KDTree\nend\n\nKNNNeighborhood specifies that the neighborhood for a given vertex j are the k nearest neighborgs. It uses a tree to search the nearest patterns.\n\nMembers\n\nk::Integer. The number of k nearest neighborgs to connect.\ntree::KDTree. Internal data structure.\nf::Function. Transformation function\n\n\n\n\n\n","category":"type"},{"location":"man/graphcreation/#SpectralClustering.KNNNeighborhood","page":"Graph Creation","title":"SpectralClustering.KNNNeighborhood","text":"KNNNeighborhood(X::Matrix, k::Integer)\n\nCreate the KNNNeighborhood type by building a k-nn tre from de data X\n\nReturn the indexes of the config.k nearest neigbors of the data point j of the data X.\n\n\n\n\n\n","category":"type"},{"location":"man/graphcreation/#SpectralClustering.PixelNeighborhood","page":"Graph Creation","title":"SpectralClustering.PixelNeighborhood","text":"struct PixelNeighborhood  <: VertexNeighborhood\n\nPixelNeighborhood defines neighborhood for a given pixel based in its spatial location. Given a pixel located at (x,y), returns every pixel inside (x+ey) (x-ey) and (xy+e)(xy-e).\n\nMembers\n\ne:: Integer. Defines the radius of the neighborhood.\n\n\n\n\n\n","category":"type"},{"location":"man/graphcreation/#SpectralClustering.RandomNeighborhood","page":"Graph Creation","title":"SpectralClustering.RandomNeighborhood","text":"struct RandomNeighborhood <: VertexNeighborhood\n    k::Integer\nend\n\nFor a given index jreturn k random vertices different from j\n\n\n\n\n\n","category":"type"},{"location":"man/graphcreation/#SpectralClustering.VertexNeighborhood","page":"Graph Creation","title":"SpectralClustering.VertexNeighborhood","text":"abstract type VertexNeighborhood end\n\nThe abstract type VertexNeighborhood provides an interface to query for the neighborhood of a given vertex. Every concrete type that inherit from VertexNeighborhood must define the function\n\nneighbors{T<:VertexNeighborhood}(cfg::T, j::Integer, data)\n\nwhich returns the neighbors list of the vertex j for the given data.\n\n\n\n\n\n","category":"type"},{"location":"man/graphcreation/#SpectralClustering.create-Tuple{DataType,VertexNeighborhood,Function,Any}","page":"Graph Creation","title":"SpectralClustering.create","text":"create(w_type::DataType, neighborhood::VertexNeighborhood, oracle::Function,X)\n\nGiven a VertexNeighborhood, a simmilarity function oracle  construct a simmilarity graph of the patterns in X.\n\n\n\n\n\n","category":"method"},{"location":"man/graphcreation/#SpectralClustering.create-Tuple{SpectralClustering.RandomKGraph}","page":"Graph Creation","title":"SpectralClustering.create","text":"create(cfg::RandomKGraph)\n\nConstruct a RandomKGraph such that every vertex is connected with other k random vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/graphcreation/#SpectralClustering.create-Tuple{VertexNeighborhood,Function,Any}","page":"Graph Creation","title":"SpectralClustering.create","text":"create(neighborhood::VertexNeighborhood, oracle::Function,X)\n\nGiven a VertexNeighborhood, a simmilarity function oracle construct a simmilarity graph of the patterns in X.\n\n\n\n\n\n","category":"method"},{"location":"man/graphcreation/#SpectralClustering.local_scale-Union{Tuple{T}, Tuple{T,Function,Any}} where T<:VertexNeighborhood","page":"Graph Creation","title":"SpectralClustering.local_scale","text":"local_scale(neighborhood::KNNNeighborhood, oracle::Function, X; k::Integer = 7)\n\nComputes thescale of each pattern according to Self-Tuning Spectral Clustering. Return a matrix containing for every pattern the local_scale.\n\nArguments\n\n- `neighborhood::KNNNeighborhood`\n- `oracle::Function`\n- `X`\n  the data\n\n\"The selection of thescale $ \\sigma $ can be done by studying thestatistics of the neighborhoods surrounding points $ i $ and $ j $ .i \" Zelnik-Manor and Perona use $ \\sigmai = d(si, sK) $ where sK$ is the $ K $ neighbor of point $ s_i $ . They \"used a single value of K=7, which gave good results even for high-dimensional data \" .\n\n\n\n\n\n","category":"method"},{"location":"man/graphcreation/#SpectralClustering.neighbors-Tuple{CliqueNeighborhood,Integer,Any}","page":"Graph Creation","title":"SpectralClustering.neighbors","text":"neighbors(config::CliqueNeighborhood, j::Integer, X)\n\nReturn every other vertex index different from j. See CliqueNeighborhood\n\n\n\n\n\n","category":"method"},{"location":"man/graphcreation/#SpectralClustering.neighbors-Union{Tuple{T}, Tuple{PixelNeighborhood,Integer,Array{T,2}}} where T<:ColorTypes.Colorant","page":"Graph Creation","title":"SpectralClustering.neighbors","text":"neighbors(cfg::PixelNeighborhood, j::Integer, img)\n\nReturns the neighbors of the pixel j according to the specified in PixelNeighborhood\n\n\n\n\n\n","category":"method"},{"location":"man/graphcreation/#SpectralClustering.RandomKGraph","page":"Graph Creation","title":"SpectralClustering.RandomKGraph","text":"struct RandomKGraph\n\nThe type RandomKGraph defines the parameters needed to create a random k-graph. Every vertex it is connected to k random neigbors.\n\nMembers\n\nnumber_of_vertices::Integer. Defines the number of vertices of the graph.\nk::Integer. Defines the minimum number of  neighborhood of every vertex.\n\n\n\n\n\n","category":"type"},{"location":"man/graphcreation/#SpectralClustering.weight-Tuple{Function,Integer,Integer,Any}","page":"Graph Creation","title":"SpectralClustering.weight","text":"weight{T<:DataAccessor}(w::Function,d::T, i::Int,j::Int,X)\n\nInvoke the weight function provided to compute the similarity between the pattern i and the pattern j.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClustering.jl-1","page":"Home","title":"SpectralClustering.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Given a set of patterns X=x_1x_2x_n in mathbb R^m, and a simmilarity function  dmathbb R^m times mathbb R^m  rightarrow mathbb R, is possible to build an affinity matrix W such that  W(ij) = d(x_i x_j). Spectral clustering algorithms obtains a low rank representation of the patterns solving the following optimization problem","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginarrayccc\nmax  mboxTr(U^T L  U) \nU in mathbb R^ntimes k  \ntextrmsa  U^T U  =   I\nendarray","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where L = D^-frac12WD^-frac12 is the Laplacian matrix derived from W according ng2002spectral and D is a diagonal matrix with the sum of the rows of W located in its main diagonal. Once obtained U, their rows are considered as the new coordinates of the patterns. In this new representation is simpler to apply a traditional clustering algorithm  shi2000normalized.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Spectral graph partitioning methods have been successfully applied to circuit layout [3, 1], load balancing [4] and image segmentation [10, 6]. As a discriminative approach, they do not make assumptions about the global structure of data. Instead, local evidence on how likely two data points belong to the same class is first collected and a global decision is then made to divide all data points into disjunct sets according to some criterion. Often, such a criterion can be interpreted in an embedding framework, where the grouping relationships among data points are preserved as much as possible in a lower-dimensional representation.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"At the Julia REPL:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"]add https://github.com/lucianolorenti/SpectralClustering.jl.git","category":"page"},{"location":"#Description-1","page":"Home","title":"Description","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The library provides functions that allow:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Build the affinity matrix. Simmilarity graph creation, Graph matrices\nPerform the embedding of the patterns in the space spanned by the eigenvectors of the matrices derived from the affinity matrix. Eigenvector Embedding\nObtain an approximation of the eigenvector in order to reduce the computational complexity. Approximate embedding\nExploiting information from multiple views. Corresponding nodes in each graph should have the same cluster membership. MultiView Embedding\nClusterize the eigenvector space. Eigenvector Clustering","category":"page"},{"location":"#Bibliography-1","page":"Home","title":"Bibliography","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"import Documenter.Documents.RawHTML\n\nBase.include(@__MODULE__, \"DocUtils.jl\")\n\nRawHTML(bibliography([\"ng2002spectral\",\"shi2000normalized\",\"yu2001understanding\"]))","category":"page"}]
}
